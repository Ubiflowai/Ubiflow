'use client';

import React, { useState, useRef } from 'react';
import { Stage, Layer, Image as KonvaImage, Circle, Line, Text, Group, Rect } from 'react-konva';
import useImage from 'use-image';
import DxfParser from 'dxf-parser';
import * as pdfjsLib from 'pdfjs-dist';
import jsPDF from 'jspdf'; // NEW IMPORT

// --- CONFIG & ASSETS ---
pdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;

const BED_ICON_URL = 'https://cdn-icons-png.flaticon.com/512/3054/3054889.png';
const SOURCE_ICON_URL = 'https://cdn-icons-png.flaticon.com/512/4492/4492453.png';

const ItemImage = ({ src, width, height }: { src: string, width: number, height: number }) => {
    // We use 'anonymous' to avoid CORS issues when exporting to PDF
    const [image] = useImage(src, 'anonymous');
    return <KonvaImage image={image} width={width} height={height} offsetX={width/2} offsetY={height/2} />;
};

const URLImage = ({ src, scale }: { src: string, scale: number }) => {
  const [image] = useImage(src);
  return <KonvaImage image={image} scaleX={scale} scaleY={scale} />;
};

interface DesignerProps {
  currentRoomType: string;
  onBedCountChange: (n: number) => void;
}

type Drawable = 
    | { id: number, type: 'LINE', points: number[], stroke: string }
    | { id: number, type: 'RECT', x: number, y: number, width: number, height: number, stroke: string }
    | { id: number, type: 'TEXT', x: number, y: number, text: string, fill: string };

export default function FloorPlanDesigner({ currentRoomType, onBedCountChange }: DesignerProps) {
  const [imageSrc, setImageSrc] = useState<string | null>(null);
  const stageRef = useRef<any>(null);
  
  // Modes
  const [editMode, setEditMode] = useState<'PIPE' | 'CAD'>('PIPE');
  const [cadTool, setCadTool] = useState<'NONE' | 'LINE' | 'RECT' | 'TEXT'>('NONE');

  // Data
  const [dxfEntities, setDxfEntities] = useState<any[]>([]); 
  const [drawables, setDrawables] = useState<Drawable[]>([]); 
  const [items, setItems] = useState<any[]>([]); 
  const [connections, setConnections] = useState<any[]>([]); 
  const [pixelsPerMeter, setPixelsPerMeter] = useState(50);
  const [dxfScale, setDxfScale] = useState(1);

  // Interaction
  const [selectedIds, setSelectedIds] = useState<number[]>([]); 
  const [selectedConnectionId, setSelectedConnectionId] = useState<number | null>(null); 
  const [tempDrawable, setTempDrawable] = useState<Drawable | null>(null);
  const isDrawing = useRef(false);
  const [drawPipeMode, setDrawPipeMode] = useState(false);
  const [selectedStartId, setSelectedStartId] = useState<number | null>(null);


  // --- 1. EXPORT TO PDF (NEW) ---
  const exportToPDF = () => {
      if (!stageRef.current) return;

      const pdf = new jsPDF('l', 'mm', 'a4'); // Landscape, A4
      const width = pdf.internal.pageSize.getWidth();
      const height = pdf.internal.pageSize.getHeight();

      // 1. Title Header
      pdf.setFontSize(18);
      pdf.text("UbiFlow Engineering Report", 10, 15);
      
      pdf.setFontSize(10);
      pdf.text(`Department: ${currentRoomType.replace('_', ' ').toUpperCase()}`, 10, 22);
      pdf.text(`Date: ${new Date().toLocaleDateString()}`, 10, 27);

      // 2. Capture the Canvas
      // We assume pixelRatio 2 for better quality
      const dataUri = stageRef.current.toDataURL({ pixelRatio: 2 });
      
      // Calculate aspect ratio to fit image in PDF
      const imgProps = pdf.getImageProperties(dataUri);
      const pdfImgHeight = (imgProps.height * (width - 20)) / imgProps.width;
      
      // Add Image
      pdf.addImage(dataUri, 'PNG', 10, 35, width - 20, pdfImgHeight);

      // 3. Add Footer / Stats
      const bedCount = items.filter(i => i.type !== 'Source').length;
      const pipeCount = connections.length;
      
      pdf.text(`Total Beds: ${bedCount}`, 10, height - 20);
      pdf.text(`Total Pipe Segments: ${pipeCount}`, 10, height - 15);
      pdf.text(`Generated by UbiFlow`, width - 50, height - 10);

      pdf.save("ubiflow-design.pdf");
  };

  // --- 2. SAVE & LOAD ---
  const saveProject = () => {
      const projectData = { version: 1, date: new Date().toISOString(), imageSrc, dxfEntities, drawables, items, connections, pixelsPerMeter, dxfScale };
      const blob = new Blob([JSON.stringify(projectData)], { type: "application/json" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = `ubiflow_project_${Date.now()}.ubiflow`; 
      document.body.appendChild(link); link.click(); document.body.removeChild(link);
  };

  const loadProject = (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
          try {
              const data = JSON.parse(event.target?.result as string);
              if (!data.version) throw new Error("Invalid UbiFlow file");
              if (data.imageSrc) setImageSrc(data.imageSrc);
              if (data.dxfEntities) setDxfEntities(data.dxfEntities);
              if (data.drawables) setDrawables(data.drawables);
              if (data.items) {
                  setItems(data.items);
                  onBedCountChange(data.items.filter((i: any) => i.type !== 'Source').length);
              }
              if (data.connections) setConnections(data.connections);
              if (data.pixelsPerMeter) setPixelsPerMeter(data.pixelsPerMeter);
              if (data.dxfScale) setDxfScale(data.dxfScale);
              alert("Project loaded!");
          } catch (err) { alert("Error loading project file."); }
      };
      reader.readAsText(file);
  };

  // --- 3. UPLOAD HANDLERS ---
  const handleUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]; if (!file) return;
    if (file.name.endsWith('.ubiflow') || file.type === 'application/json') { loadProject(e); return; }
    if (file.type === 'application/pdf') {
        const reader = new FileReader();
        reader.onload = async (evt) => { try { await processPdf(new Uint8Array(evt.target?.result as ArrayBuffer)); } catch (e) { console.error(e); alert("PDF Error"); } };
        reader.readAsArrayBuffer(file);
    } else if (file.type.includes('image')) { setImageSrc(URL.createObjectURL(file)); setDxfEntities([]); }
    else if (file.name.endsWith('.dxf')) {
        const reader = new FileReader();
        reader.onload = (evt) => { try { processDxf(new DxfParser().parseSync(evt.target?.result as string)); } catch (e) { alert("DXF Error"); } };
        reader.readAsText(file);
    }
  };

  const processPdf = async (data: Uint8Array) => {
      const pdf = await pdfjsLib.getDocument(data).promise;
      const page = await pdf.getPage(1);
      const viewport = page.getViewport({ scale: 2.0 });
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d'); if (!ctx) return;
      canvas.width = viewport.width; canvas.height = viewport.height;
      await page.render({ canvasContext: ctx, viewport } as any).promise;
      setImageSrc(canvas.toDataURL()); setDxfEntities([]);
  };

  const processDxf = (dxf: any) => {
      if (!dxf || !dxf.entities) return;
      const newEntities: any[] = [];
      let minX = Infinity, maxX = -Infinity;
      dxf.entities.forEach((entity: any, idx: number) => {
          const id = Date.now() + idx;
          if (entity.type === 'LINE') {
              newEntities.push({ id, type: 'LINE', points: [entity.vertices[0].x, -entity.vertices[0].y, entity.vertices[1].x, -entity.vertices[1].y] });
              minX = Math.min(minX, entity.vertices[0].x, entity.vertices[1].x); maxX = Math.max(maxX, entity.vertices[0].x, entity.vertices[1].x);
          }
      });
      setDxfScale(600 / (maxX - minX || 1));
      setDxfEntities(newEntities); setImageSrc(null);
  };

  // --- 4. ITEM & DRAWING HANDLERS ---
  const addItem = (type: 'Bed' | 'Source') => {
    let label = type === 'Bed' ? (currentRoomType ? currentRoomType.split('_')[0].toUpperCase() : 'BED') : type;
    const iconUrl = type === 'Bed' ? BED_ICON_URL : SOURCE_ICON_URL;
    const newItem = { id: Date.now(), x: 100, y: 100, type, label, iconUrl };
    const newItems = [...items, newItem]; setItems(newItems);
    if (type === 'Bed') onBedCountChange(newItems.filter(i => i.type !== 'Source').length);
  };

  const handleItemClick = (id: number) => {
      if (editMode === 'PIPE' && drawPipeMode) {
          if (selectedStartId === null) setSelectedStartId(id);
          else if (selectedStartId !== id) {
              setConnections([...connections, { id: Date.now(), start: selectedStartId, end: id, bendOffset: 0 }]);
              setSelectedStartId(null);
          }
      }
  };

  const handleStageMouseDown = (e: any) => {
      if (e.target === e.target.getStage()) { setSelectedConnectionId(null); if(cadTool === 'NONE') setSelectedIds([]); }
      if (editMode !== 'CAD' || cadTool === 'NONE') return;
      isDrawing.current = true;
      const pos = e.target.getStage().getPointerPosition();
      const id = Date.now();
      if (cadTool === 'LINE') setTempDrawable({ id, type: 'LINE', points: [pos.x, pos.y, pos.x, pos.y], stroke: 'black' });
      else if (cadTool === 'RECT') setTempDrawable({ id, type: 'RECT', x: pos.x, y: pos.y, width: 0, height: 0, stroke: 'black' });
      else if (cadTool === 'TEXT') {
          const text = prompt("Enter text:");
          if (text) setDrawables([...drawables, { id, type: 'TEXT', x: pos.x, y: pos.y, text, fill: 'black' }]);
          setCadTool('NONE'); isDrawing.current = false;
      }
  };

  const handleStageMouseMove = (e: any) => {
      if (!isDrawing.current || !tempDrawable) return;
      const pos = e.target.getStage().getPointerPosition();
      if (tempDrawable.type === 'LINE') setTempDrawable({ ...tempDrawable, points: [tempDrawable.points[0], tempDrawable.points[1], pos.x, pos.y] });
      else if (tempDrawable.type === 'RECT') setTempDrawable({ ...tempDrawable, width: pos.x - tempDrawable.x, height: pos.y - tempDrawable.y });
  };

  const handleStageMouseUp = () => { isDrawing.current = false; if (tempDrawable) { setDrawables([...drawables, tempDrawable]); setTempDrawable(null); } };

  const handleSelect = (id: number) => {
      if (editMode !== 'CAD' || cadTool !== 'NONE') return;
      if (selectedIds.includes(id)) setSelectedIds(selectedIds.filter(sid => sid !== id));
      else setSelectedIds([...selectedIds, id]);
  };

  const deleteSelected = () => {
      setDxfEntities(dxfEntities.filter(e => !selectedIds.includes(e.id)));
      setDrawables(drawables.filter(d => !selectedIds.includes(d.id)));
      setSelectedIds([]);
  };

  const getDistance = (start: any, end: any) => { return ((Math.abs(end.x - start.x) + Math.abs(end.y - start.y)) / pixelsPerMeter).toFixed(2); };

  return (
    <div className="w-full p-6 bg-white rounded-xl border-2 border-slate-200 mt-8">
      
      {/* --- TOP TOOLBAR --- */}
      <div className="flex justify-between items-center mb-4">
        <div className="flex bg-slate-100 p-1 rounded-lg">
            <button onClick={() => {setEditMode('PIPE'); setCadTool('NONE')}} className={`px-4 py-2 text-sm font-bold rounded-md transition-colors ${editMode === 'PIPE' ? 'bg-white shadow text-blue-600' : 'text-slate-500 hover:text-slate-700'}`}>Pipe System</button>
            <button onClick={() => {setEditMode('CAD'); setDrawPipeMode(false)}} className={`px-4 py-2 text-sm font-bold rounded-md transition-colors ${editMode === 'CAD' ? 'bg-white shadow text-orange-600' : 'text-slate-500 hover:text-slate-700'}`}>CAD Edit</button>
        </div>
        
        <div className="flex gap-2">
            {/* NEW PDF BUTTON */}
            <button onClick={exportToPDF} className="bg-red-600 text-white px-3 py-2 rounded text-sm font-bold hover:bg-red-700 shadow-sm flex items-center gap-1">
                üìÑ PDF
            </button>
            <button onClick={saveProject} className="bg-slate-800 text-white px-3 py-2 rounded text-sm font-bold hover:bg-slate-900">üíæ Save</button>
            <div className="relative overflow-hidden">
                <button className="bg-slate-200 text-slate-700 px-3 py-2 rounded text-sm font-bold hover:bg-slate-300">üìÇ Load</button>
                <input type="file" onChange={handleUpload} accept=".ubiflow,.json" className="absolute inset-0 opacity-0 cursor-pointer"/>
            </div>
        </div>

        <div className="flex items-center gap-2">
            <span className="text-xs font-bold text-slate-500">SCALE: 1m =</span>
            <input type="number" value={pixelsPerMeter} onChange={(e) => setPixelsPerMeter(Number(e.target.value))} className="w-12 p-1 text-sm font-bold border rounded text-center"/>
            <span className="text-xs text-slate-500">px</span>
        </div>
      </div>
      
      {/* --- SECONDARY TOOLBAR --- */}
      <div className={`flex flex-wrap gap-3 mb-4 p-3 rounded-lg border items-center ${editMode === 'PIPE' ? 'bg-blue-50 border-blue-200' : 'bg-orange-50 border-orange-200'}`}>
        
        <div className="mr-4 relative group">
            <button className="px-3 py-2 bg-white border rounded text-sm font-bold text-slate-600 hover:bg-slate-50">üìÑ Import Background</button>
            <input type="file" onChange={handleUpload} accept=".dxf,.pdf,image/*" className="absolute inset-0 opacity-0 cursor-pointer"/>
        </div>

        {editMode === 'PIPE' ? (
            <>
                <button onClick={() => addItem('Source')} className="flex items-center gap-2 bg-white border-2 border-red-200 text-red-700 px-3 py-2 rounded font-bold text-sm hover:bg-red-50"><img src={SOURCE_ICON_URL} width={16}/> Source</button>
                <button onClick={() => addItem('Bed')} className="flex items-center gap-2 bg-white border-2 border-emerald-200 text-emerald-700 px-3 py-2 rounded font-bold text-sm hover:bg-emerald-50"><img src={BED_ICON_URL} width={16}/> Bed</button>
                <div className="h-6 w-px bg-blue-200 mx-2"></div>
                <button onClick={() => { setDrawPipeMode(!drawPipeMode); setSelectedStartId(null); }} className={`px-3 py-2 rounded font-bold text-sm border-2 ${drawPipeMode ? 'bg-blue-600 text-white border-blue-600' : 'bg-white border-blue-300 text-blue-600'}`}>
                    {drawPipeMode ? 'üî¥ Drawing...' : 'Draw Pipe'}
                </button>
                {selectedConnectionId && (
                     <button onClick={() => { setConnections(connections.filter(c => c.id !== selectedConnectionId)); setSelectedConnectionId(null); }} className="ml-auto bg-red-500 text-white px-3 py-2 rounded font-bold text-sm hover:bg-red-600">Delete Pipe</button>
                )}
            </>
        ) : (
            <>
                <div className="flex gap-1 bg-white rounded-md border p-1">
                    <button onClick={() => setCadTool('NONE')} className={`p-2 rounded ${cadTool === 'NONE' ? 'bg-slate-200' : 'hover:bg-slate-100'}`} title="Select">üëÜ</button>
                    <button onClick={() => setCadTool('LINE')} className={`p-2 rounded ${cadTool === 'LINE' ? 'bg-slate-200' : 'hover:bg-slate-100'}`} title="Line">üìè</button>
                    <button onClick={() => setCadTool('RECT')} className={`p-2 rounded ${cadTool === 'RECT' ? 'bg-slate-200' : 'hover:bg-slate-100'}`} title="Rect">‚¨ú</button>
                    <button onClick={() => setCadTool('TEXT')} className={`p-2 rounded ${cadTool === 'TEXT' ? 'bg-slate-200' : 'hover:bg-slate-100'}`} title="Text">AÃ±</button>
                </div>
                <div className="h-6 w-px bg-orange-200 mx-2"></div>
                <button onClick={deleteSelected} disabled={selectedIds.length === 0} className="bg-red-500 text-white px-3 py-2 rounded font-bold text-sm disabled:opacity-50 hover:bg-red-600">Delete ({selectedIds.length})</button>
                <button onClick={() => {setDxfEntities([]); setDrawables([]);}} className="text-red-500 text-xs font-bold underline px-2 ml-auto">Clear All</button>
            </>
        )}
      </div>

      {/* --- CANVAS --- */}
      <div className={`relative w-full h-[600px] bg-slate-100 rounded-xl overflow-hidden border-2 ${editMode === 'CAD' ? 'border-orange-400' : 'border-slate-300'} shadow-inner cursor-${cadTool !== 'NONE' ? 'crosshair' : 'default'}`}>
        <Stage 
            ref={stageRef} width={800} height={600} 
            draggable={cadTool === 'NONE'}
            onMouseDown={handleStageMouseDown}
            onMouseMove={handleStageMouseMove}
            onMouseUp={handleStageMouseUp}
        >
          <Layer>
            {imageSrc && <URLImage src={imageSrc} scale={0.5} />}
            {/* DXF */}
            {dxfEntities.length > 0 && (
                <Group x={100} y={500} scaleX={dxfScale} scaleY={dxfScale}>
                    {dxfEntities.map((line) => {
                        const isSelected = selectedIds.includes(line.id);
                        return ( <Line key={line.id} points={line.points} stroke={isSelected ? '#f97316' : '#94a3b8'} strokeWidth={(isSelected ? 3 : 1) / dxfScale} hitStrokeWidth={10/dxfScale} draggable={editMode === 'CAD' && cadTool === 'NONE'} onClick={() => handleSelect(line.id)} /> );
                    })}
                </Group>
            )}
            {/* User Drawings */}
            {drawables.map((d) => {
                const isSelected = selectedIds.includes(d.id);
                const commonProps = { key: d.id, draggable: editMode === 'CAD' && cadTool === 'NONE', onClick: () => handleSelect(d.id), stroke: isSelected ? '#f97316' : 'black', strokeWidth: isSelected ? 3 : 2 };
                if (d.type === 'LINE') return <Line {...commonProps} points={d.points} hitStrokeWidth={10} />;
                if (d.type === 'RECT') return <Rect {...commonProps} x={d.x} y={d.y} width={d.width} height={d.height} />;
                if (d.type === 'TEXT') return <Text {...commonProps} x={d.x} y={d.y} text={d.text} fill={isSelected ? '#f97316' : 'black'} fontSize={16} strokeWidth={0} />;
                return null;
            })}
            
            {/* Temp Drawing */}
            {tempDrawable && tempDrawable.type === 'LINE' && <Line points={tempDrawable.points} stroke="#f97316" strokeWidth={2} dash={[5,5]} />}
            {tempDrawable && tempDrawable.type === 'RECT' && <Rect x={tempDrawable.x} y={tempDrawable.y} width={tempDrawable.width} height={tempDrawable.height} stroke="#f97316" strokeWidth={2} dash={[5,5]} />}

            {/* Pipes */}
            {connections.map((conn) => {
                const start = items.find(i => i.id === conn.start); const end = items.find(i => i.id === conn.end); if (!start || !end) return null;
                const isSelected = selectedConnectionId === conn.id;
                const midX = ((start.x + end.x) / 2) + (conn.bendOffset || 0);
                const points = [start.x, start.y, midX, start.y, midX, end.y, end.x, end.y];
                return (
                    <Group key={conn.id}>
                        <Line points={points} stroke={isSelected ? '#f97316' : '#3b82f6'} strokeWidth={4} lineCap="round" lineJoin="round" onClick={() => setSelectedConnectionId(conn.id)} hitStrokeWidth={15} />
                        <Text x={midX+5} y={(start.y+end.y)/2} text={`${getDistance(start, end)}m`} fontSize={12} fontStyle="bold" fill={isSelected ? '#c2410c' : '#1e3a8a'} padding={4} fillAfterStrokeEnabled stroke="white" strokeWidth={3}/>
                        <Text x={midX+5} y={(start.y+end.y)/2} text={`${getDistance(start, end)}m`} fontSize={12} fontStyle="bold" fill={isSelected ? '#c2410c' : '#1e3a8a'} padding={4}/>
                        {isSelected && editMode === 'PIPE' && (
                            <Circle x={midX} y={(start.y+end.y)/2} radius={6} fill="#f97316" stroke="white" strokeWidth={2} draggable onDragMove={(e) => { setConnections(connections.map(c => c.id === conn.id ? { ...c, bendOffset: e.target.x() - (start.x + end.x) / 2 } : c)); }} />
                        )}
                    </Group>
                );
            })}

            {/* Items */}
            {items.map((item) => (
              <Group key={item.id} draggable={editMode === 'PIPE'} x={item.x} y={item.y}
                onDragEnd={(e) => setItems(items.map(i => i.id === item.id ? { ...i, x: e.target.x(), y: e.target.y() } : i))}
                onClick={() => handleItemClick(item.id)}
                onDblClick={() => {
                    const newItems = items.filter(i => i.id !== item.id); setItems(newItems);
                    setConnections(connections.filter(c => c.start !== item.id && c.end !== item.id));
                    if (item.type !== 'Source') onBedCountChange(newItems.filter(i => i.type !== 'Source').length);
                }}
              >
                {selectedStartId === item.id && <Circle radius={25} stroke="#3b82f6" strokeWidth={3} dash={[4, 4]} />}
                <ItemImage src={item.iconUrl} width={40} height={40} />
                <Text y={22} x={-20} text={item.label} fontSize={11} fill="black" fontStyle="bold" align="center" width={40} />
              </Group>
            ))}
          </Layer>
        </Stage>
      </div>
      
      <div className={`mt-3 p-2 text-center text-xs font-mono rounded-b-lg border-t-2 ${editMode === 'CAD' ? 'bg-orange-50 text-orange-800 border-orange-200' : 'bg-blue-50 text-blue-800 border-blue-200'}`}>
          {editMode === 'CAD' ? (cadTool === 'NONE' ? "CAD: Select/Drag items." : `DRAWING ${cadTool}...`) : "PIPE: Drag items. Click 'Draw Pipe' to connect."}
      </div>
    </div>
  );
}